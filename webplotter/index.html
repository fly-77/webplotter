<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arduino WebSerial Plotter</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.0.4/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.2.0/dist/chartjs-adapter-luxon.min.js"></script>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #34495e;
            --success: #2ecc71;
            --warning: #f39c12;
            --info: #1abc9c;
            --gray: #7f8c8d;
            --card-bg: #ffffff;
            --border: #dfe6e9;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, var(--light) 0%, #d6dbdc 100%);
            color: var(--dark);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: var(--primary);
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 1rem;
            color: var(--light);
            opacity: 0.8;
        }

        .card {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border);
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--primary);
        }

        select, input, button {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid var(--border);
            border-radius: 5px;
            font-size: 1rem;
            background: white;
        }

        button {
            background: var(--secondary);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover {
            background: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: var(--secondary);
        }

        .btn-success {
            background: var(--success);
        }

        .btn-danger {
            background: var(--accent);
        }

        .btn-warning {
            background: var(--warning);
        }

        .btn-info {
            background: var(--info);
        }

        .btn-sm {
            padding: 6px 10px;
            font-size: 0.85rem;
            width: auto;
        }

        .plots-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 25px;
        }

        .plot-card {
            position: relative;
            height: auto;
            display: flex;
            flex-direction: column;
        }

        .plot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .plot-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary);
        }

        .plot-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
            margin-bottom: 10px;
        }

        .plot-controls button {
            width: auto;
            padding: 6px 10px;
            font-size: 0.85rem;
        }

        .plot-area {
            flex: 1;
            position: relative;
            min-height: 300px;
            height: 300px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            border: 1px solid var(--border);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            display: inline-block;
        }

        .legend-input {
            width: 100px;
            padding: 2px 5px;
            font-size: 0.85rem;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: var(--primary);
            color: white;
            border-radius: 5px;
            margin-top: 20px;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        .connected {
            background: var(--success);
        }

        .disconnected {
            background: var(--accent);
        }

        .data-count {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.2);
            padding: 3px 8px;
            border-radius: 4px;
        }

        .plot-settings-panel {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            margin: 15px;
            background: rgba(248, 249, 250, 0.95);
            z-index: 10;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            overflow-y: auto;
            display: none;
        }

        .plot-settings-panel.open {
            display: block;
        }

        .settings-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
        }

        .settings-group {
            flex: 1;
            min-width: 200px;
        }

        .axis-settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .line-settings {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .line-setting-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
            background: white;
            border-radius: 5px;
            border: 1px solid #eee;
        }

        .line-color-preview {
            width: 20px;
            height: 3px;
        }

        .line-visibility {
            margin-left: auto;
        }

        .thickness-select {
            width: 70px;
            padding: 3px;
        }

        .ma-settings {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .ma-window-input {
            width: 60px;
            padding: 3px;
        }

        .export-btn {
            margin-top: 15px;
            background: var(--success);
        }

        .csv-settings-panel {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 1px solid var(--border);
        }

        .csv-settings-panel.open {
            display: block;
        }

        @media (max-width: 1200px) {
            .plots-container {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .settings-grid {
                grid-template-columns: 1fr;
            }
            
            .plot-card {
                height: auto;
            }
            
            .plot-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .plot-controls button {
                width: 100%;
            }

            .axis-settings {
                grid-template-columns: 1fr;
            }
            
            .line-setting-item {
                flex-wrap: wrap;
            }
            
            .ma-settings {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Arduino WebSerial Plotter</h1>
            <div class="subtitle">Visualize your Arduino's serial data in real-time</div>
        </header>

        <div class="settings-grid">
            <div class="card">
                <h2>Connection Settings</h2>
                <div class="control-group">
                    <label for="port-select">Serial Port</label>
                    <select id="port-select">
                        <option value="">Select a port</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="baud-rate">Baud Rate</label>
                    <select id="baud-rate">
                        <option value="9600">9600</option>
                        <option value="19200">19200</option>
                        <option value="38400">38400</option>
                        <option value="57600">57600</option>
                        <option value="115200" selected>115200</option>
                    </select>
                </div>
                <button id="connect-btn" class="btn-primary">
                    <span>Connect</span>
                </button>
            </div>

            <div class="card">
                <h2>Plot Configuration</h2>
                <div class="control-group">
                    <label for="plot-count">Number of Plot Windows</label>
                    <select id="plot-count">
                        <option value="1">1 Plot</option>
                        <option value="2">2 Plots</option>
                        <option value="3" selected>3 Plots</option>
                        <option value="4">4 Plots</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="data-format">Data Format</label>
                    <input type="text" id="data-format" value="0,3,7" placeholder="Separator indices (e.g., 0,3,7)">
                    <small>Enter comma-separated indices where data splits between plots</small>
                </div>
                <button id="apply-plot-config" class="btn-info">
                    <span>Apply Configuration</span>
                </button>
            </div>

            <div class="card">
                <h2>Global Controls</h2>
                <div class="control-group">
                    <button id="start-stop-btn" class="btn-success">
                        <span>Start Plotting</span>
                    </button>
                </div>
                <div class="control-group">
                    <button id="clear-all-btn" class="btn-warning">
                        <span>Clear All Plots</span>
                    </button>
                </div>
                <!-- Add this section for CSV format settings -->
                <div class="control-group">
                    <button id="csv-settings-toggle" class="btn-info">
                        <span>CSV Export Settings</span>
                    </button>
                    <div class="csv-settings-panel" id="csv-settings-panel">
                        <div class="settings-group">
                            <label for="csv-thousand-separator">Thousand Separator</label>
                            <select id="csv-thousand-separator">
                                <option value="none" selected>None</option>
                                <option value=";">Comma (,)</option>
                                <option value=",">Period (.)</option>
                                <option value=" ">Space ( )</option>                             
                            </select>
                        </div>
                        <div class="settings-group">
                            <label for="csv-decimal-separator">Decimal Separator</label>
                            <select id="csv-decimal-separator">
                                <option value="," selected> Comma (,)</option>
                                <option value=".">Period (.)</option>
                            </select>
                        </div>
                        <div class="settings-group">
                            <label for="csv-value-separator">Value Separator</label>
                            <select id="csv-value-separator">
                                <option value=",">Comma (,)</option>
                                <option value=";" selected>Semicolon (;)</option>
                                <option value="\t">Tab</option>
                                <option value="|">Pipe (|)</option>
                            </select>
                        </div>
                        <button class="btn-sm btn-success" id="apply-csv-settings">Apply CSV Settings</button>
                    </div>
                </div>
            </div>

        </div>

        <div class="plots-container" id="plots-container">
            <!-- Plot cards will be generated here -->
        </div>

        <div class="status-bar">
            <div class="connection-status">
                <span class="status-indicator disconnected" id="status-indicator"></span>
                <span id="status-text">Disconnected</span>
            </div>
            <div class="data-info">
                <span>Data points: </span>
                <span class="data-count" id="data-count">0</span>
            </div>
        </div>
    </div>

    <script>
        // Global state
        const state = {
            connected: false,
            plotting: false,
            plotCount: 3,
            separatorIndices: [0, 3, 7],
            dataPoints: 0,
            charts: [],
            data: [],
            port: null,
            reader: null,
            dataBuffer: "", // Buffer to accumulate incoming data
            plotSettings: [], // Store individual plot settings
            csvThousandSeparator: 'none',
            csvDecimalSeparator: ',',
            csvValueSeparator: ';'
        };

        // Colors for the data lines
        const lineColors = [
            '#3498db', '#e74c3c', '#2ecc71', '#f39c12', 
            '#9b59b6', '#1abc9c', '#d35400', '#c0392b'
        ];

        // Colors for moving average lines (darker versions of the original colors)
        const maLineColors = [
            '#206694', '#9c2315', '#1e8449', '#9c6309',
            '#6c3483', '#117a65', '#943a00', '#7e2c1f'
        ];

        // Initialize the application
        function init() {
            console.log("Initializing application...");
            console.log("Current state:", JSON.parse(JSON.stringify(state)));
            renderPlotWindows();
            setupEventListeners();
            updateUiState();
            console.log("Application initialized");
        }

        // Render plot windows based on current configuration
        function renderPlotWindows() {
            console.log("Rendering plot windows...");
            console.log("Plot count:", state.plotCount);
            console.log("Separator indices:", state.separatorIndices);
            
            const container = document.getElementById('plots-container');
            container.innerHTML = '';
            state.charts = [];
            state.plotSettings = [];

            for (let i = 0; i < state.plotCount; i++) {
                const plotCard = document.createElement('div');
                plotCard.className = 'card plot-card';
                
                const plotId = `plot-${i}`;
                const startIndex = state.separatorIndices[i];
                const endIndex = i < state.plotCount - 1 ? state.separatorIndices[i + 1] : undefined;
                const dataCount = endIndex !== undefined ? endIndex - startIndex : lineColors.length - startIndex;
                
                // Initialize settings for this plot
                const plotSetting = {
                    lineThickness: Array(dataCount).fill(2),
                    legendLabels: Array(dataCount).fill('').map((_, idx) => `Data ${startIndex + idx}`),
                    visible: Array(dataCount).fill(true),
                    xLabel: 'Time (data points)',
                    yLabel: 'Value',
                    maWindow: Array(dataCount).fill(10),
                    maVisible: Array(dataCount).fill(false),
                    maLegendLabels: Array(dataCount).fill('').map((_, idx) => `MA ${startIndex + idx}`),
                    // Add these new CSV format settings:
                    csvThousandSeparator: 'none', // 'none', ',', '.', ' ', etc.
                    csvValueSeparator: ';', // ',', ';', '\t', etc.
                    csvDecimalSeparator: ',' // '.', ','
                };
                state.plotSettings.push(plotSetting);
                
                plotCard.innerHTML = `
                    <div class="plot-header">
                        <div class="plot-title">Plot ${i + 1} (Data: ${startIndex}${endIndex !== undefined ? `-${endIndex-1}` : '+'})</div>
                        <button class="btn-sm btn-info settings-toggle" data-plot="${i}">Settings</button>
                    </div>
                    <div class="plot-area">
                        <canvas id="${plotId}"></canvas>
                    </div>
                    <div class="plot-controls">
                        <button class="btn-info scale-btn" data-plot="${i}" data-action="autoscale">Auto Scale Y</button>
                        <button class="btn-info scale-btn" data-plot="${i}" data-action="increase-y">+ Y Scale</button>
                        <button class="btn-info scale-btn" data-plot="${i}" data-action="decrease-y">- Y Scale</button>
                        <button class="btn-info scale-btn" data-plot="${i}" data-action="increase-x">+ X Range</button>
                        <button class="btn-info scale-btn" data-plot="${i}" data-action="decrease-x">- X Range</button>
                        <button class="btn-warning clear-btn" data-plot="${i}">Clear Plot</button>
                    </div>
                    <div class="plot-settings-panel" id="settings-${i}">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3>Plot Settings</h3>
                            <button class="btn-sm btn-danger close-settings" data-plot="${i}">X</button>
                        </div>
                        <div class="axis-settings">
                            <div class="settings-group">
                                <label for="x-label-${i}">X-axis Label</label>
                                <input type="text" id="x-label-${i}" value="${plotSetting.xLabel}" class="axis-label-input" data-plot="${i}" data-axis="x">
                            </div>
                            <div class="settings-group">
                                <label for="y-label-${i}">Y-axis Label</label>
                                <input type="text" id="y-label-${i}" value="${plotSetting.yLabel}" class="axis-label-input" data-plot="${i}" data-axis="y">
                            </div>
                        </div>
                        <div class="settings-group">
                            <label>Line Settings:</label>
                            <div class="line-settings" id="line-settings-${i}">
                                ${Array(dataCount).fill(0).map((_, j) => `
                                    <div class="line-setting-item">
                                        <span class="line-color-preview" style="background-color: ${lineColors[(startIndex + j) % lineColors.length]}"></span>
                                        <input type="text" class="legend-input" value="${plotSetting.legendLabels[j]}" 
                                            data-plot="${i}" data-index="${j}" placeholder="Legend">
                                        <label>Thickness:</label>
                                        <select class="thickness-select" data-plot="${i}" data-index="${j}">
                                            <option value="1" ${plotSetting.lineThickness[j] === 1 ? 'selected' : ''}>1px</option>
                                            <option value="2" ${plotSetting.lineThickness[j] === 2 ? 'selected' : ''}>2px</option>
                                            <option value="3" ${plotSetting.lineThickness[j] === 3 ? 'selected' : ''}>3px</option>
                                            <option value="4" ${plotSetting.lineThickness[j] === 4 ? 'selected' : ''}>4px</option>
                                            <option value="5" ${plotSetting.lineThickness[j] === 5 ? 'selected' : ''}>5px</option>
                                        </select>
                                        <label class="line-visibility">
                                            <input type="checkbox" class="visibility-toggle" data-plot="${i}" data-index="${j}" ${plotSetting.visible[j] ? 'checked' : ''}> Visible
                                        </label>
                                        <div class="ma-settings">
                                            <label>MA Window:</label>
                                            <input type="number" class="ma-window-input" value="${plotSetting.maWindow[j]}" min="2" max="100" data-plot="${i}" data-index="${j}">
                                            <input type="text" class="legend-input" value="${plotSetting.maLegendLabels[j]}" 
                                                data-plot="${i}" data-index="${j}" data-ma="true" placeholder="MA Legend">
                                            <label>
                                                <input type="checkbox" class="ma-visibility-toggle" data-plot="${i}" data-index="${j}" ${plotSetting.maVisible[j] ? 'checked' : ''}> Show MA
                                            </label>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <button class="btn-success export-btn" data-plot="${i}">Export CSV</button>
                    </div>
                    <div class="legend" id="legend-${i}"></div>
                `;
                                
                container.appendChild(plotCard);
                
                // Initialize chart
                const ctx = document.getElementById(plotId).getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: []
                    },
                    options: {
                        animation: {
                            duration: 0
                        },
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false // Hide the default legend
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: plotSetting.xLabel
                                },
                                min: 0,
                                max: 100
                            },
                            y: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: plotSetting.yLabel
                                }
                            }
                        }
                    }
                });
                
                // Store scale state for each chart
                chart.scaleState = {
                    yMin: null,
                    yMax: null,
                    xRange: 100, // Default X range
                    xMin: 0,
                    xMax: 100
                };
                
                state.charts.push(chart);
                console.log(`Created plot ${i} with data indices ${startIndex} to ${endIndex || 'end'}`);
            }
            
            updateLegends();
            console.log("Plot windows rendered");
        }

        // Update legends for each plot
        function updateLegends() {
            console.log("Updating legends...");
            for (let i = 0; i < state.plotCount; i++) {
                const legendEl = document.getElementById(`legend-${i}`);
                const startIndex = state.separatorIndices[i];
                const endIndex = i < state.plotCount - 1 ? state.separatorIndices[i + 1] : undefined;
                const dataCount = endIndex !== undefined ? endIndex - startIndex : lineColors.length - startIndex;
                
                legendEl.innerHTML = '';
                
                for (let j = 0; j < dataCount; j++) {
                    const dataIndex = startIndex + j;
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    
                    // Use custom label if available, otherwise default
                    const label = state.plotSettings[i].legendLabels[j] || `Data ${dataIndex}`;
                    const maLabel = state.plotSettings[i].maLegendLabels[j] || `MA ${dataIndex}`;
                    
                    legendItem.innerHTML = `
                        <span class="legend-color" style="background-color: ${lineColors[dataIndex % lineColors.length]}"></span>
                        <span>${label}</span>
                    `;
                    legendEl.appendChild(legendItem);
                    
                    // Add MA legend if visible
                    if (state.plotSettings[i].maVisible[j]) {
                        const maLegendItem = document.createElement('div');
                        maLegendItem.className = 'legend-item';
                        maLegendItem.innerHTML = `
                            <span class="legend-color" style="background-color: ${maLineColors[dataIndex % maLineColors.length]}"></span>
                            <span>${maLabel}</span>
                        `;
                        legendEl.appendChild(maLegendItem);
                    }
                }
                console.log(`Plot ${i} legend: ${dataCount} data series`);
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            console.log("Setting up event listeners...");
            
            // Connect button
            document.getElementById('connect-btn').addEventListener('click', toggleConnection);
            
            // Start/stop button
            document.getElementById('start-stop-btn').addEventListener('click', togglePlotting);
            
            // Clear all button
            document.getElementById('clear-all-btn').addEventListener('click', clearAllPlots);
            
            // Apply plot configuration
            document.getElementById('apply-plot-config').addEventListener('click', applyPlotConfig);
            
            // Plot count change
            document.getElementById('plot-count').addEventListener('change', function() {
                console.log("Plot count changed to:", this.value);
                state.plotCount = parseInt(this.value);
                renderPlotWindows();
            });
            
            // Delegated events for plot controls
            document.getElementById('plots-container').addEventListener('click', function(e) {
                if (e.target.classList.contains('scale-btn')) {
                    const plotIndex = parseInt(e.target.dataset.plot);
                    const action = e.target.dataset.action;
                    console.log(`Scale action: ${action} on plot ${plotIndex}`);
                    handleScaleAction(plotIndex, action);
                } else if (e.target.classList.contains('clear-btn')) {
                    const plotIndex = parseInt(e.target.dataset.plot);
                    console.log(`Clear plot ${plotIndex}`);
                    clearPlot(plotIndex);
                } else if (e.target.classList.contains('settings-toggle')) {
                    const plotIndex = parseInt(e.target.dataset.plot);
                    toggleSettingsPanel(plotIndex);
                } else if (e.target.classList.contains('close-settings')) {
                    const plotIndex = parseInt(e.target.dataset.plot);
                    toggleSettingsPanel(plotIndex);
                } else if (e.target.classList.contains('export-btn')) {
                    const plotIndex = parseInt(e.target.dataset.plot);
                    exportCSV(plotIndex);
                }
            });
            
            // Delegated events for settings changes
            document.getElementById('plots-container').addEventListener('change', function(e) {
                if (e.target.classList.contains('thickness-select')) {
                    const plotIndex = parseInt(e.target.dataset.plot);
                    const dataIndex = parseInt(e.target.dataset.index);
                    const thickness = parseInt(e.target.value);
                    updateLineThickness(plotIndex, dataIndex, thickness);
                } else if (e.target.classList.contains('visibility-toggle')) {
                    const plotIndex = parseInt(e.target.dataset.plot);
                    const dataIndex = parseInt(e.target.dataset.index);
                    const visible = e.target.checked;
                    toggleDataVisibility(plotIndex, dataIndex, visible);
                } else if (e.target.classList.contains('axis-label-input')) {
                    const plotIndex = parseInt(e.target.dataset.plot);
                    const axis = e.target.dataset.axis;
                    const label = e.target.value;
                    updateAxisLabel(plotIndex, axis, label);
                } else if (e.target.classList.contains('ma-window-input')) {
                    const plotIndex = parseInt(e.target.dataset.plot);
                    const dataIndex = parseInt(e.target.dataset.index);
                    const windowSize = parseInt(e.target.value);
                    updateMaWindow(plotIndex, dataIndex, windowSize);
                } else if (e.target.classList.contains('ma-visibility-toggle')) {
                    const plotIndex = parseInt(e.target.dataset.plot);
                    const dataIndex = parseInt(e.target.dataset.index);
                    const visible = e.target.checked;
                    toggleMaVisibility(plotIndex, dataIndex, visible);
                }
            });
            
            // Delegated events for legend text changes
            document.getElementById('plots-container').addEventListener('input', function(e) {
                if (e.target.classList.contains('legend-input')) {
                    const plotIndex = parseInt(e.target.dataset.plot);
                    const dataIndex = parseInt(e.target.dataset.index);
                    const label = e.target.value;
                    const isMa = e.target.dataset.ma === 'true';
                    
                    if (isMa) {
                        updateMaLegendLabel(plotIndex, dataIndex, label);
                    } else {
                        updateLegendLabel(plotIndex, dataIndex, label);
                    }
                }
            });
            
            // CSV settings toggle
            document.getElementById('csv-settings-toggle').addEventListener('click', function() {
                const panel = document.getElementById('csv-settings-panel');
                panel.classList.toggle('open');
                const span = this.querySelector('span');
                span.textContent = panel.classList.contains('open') ? 'Hide CSV Settings' : 'CSV Export Settings';
            });

            // Apply CSV settings
            document.getElementById('apply-csv-settings').addEventListener('click', function() {
                state.csvThousandSeparator = document.getElementById('csv-thousand-separator').value;
                state.csvDecimalSeparator = document.getElementById('csv-decimal-separator').value;
                state.csvValueSeparator = document.getElementById('csv-value-separator').value;
                alert('CSV export settings applied!');
            });
            
            console.log("Event listeners set up");
        }

        // Toggle settings panel for a plot
        function toggleSettingsPanel(plotIndex) {
            const settingsPanel = document.getElementById(`settings-${plotIndex}`);
            const isOpening = !settingsPanel.classList.contains('open');
            
            settingsPanel.classList.toggle('open');
            
            const button = document.querySelector(`.settings-toggle[data-plot="${plotIndex}"]`);
            if (isOpening) {
                button.textContent = 'Close Settings';
            } else {
                button.textContent = 'Settings';
            }
            
            // Force chart resize to maintain proper dimensions
            if (state.charts[plotIndex]) {
                setTimeout(() => {
                    state.charts[plotIndex].resize();
                }, 100);
            }
        }

        // Update line thickness for a data series
        function updateLineThickness(plotIndex, dataIndex, thickness) {
            console.log(`Updating line thickness for plot ${plotIndex}, data ${dataIndex} to ${thickness}px`);
            state.plotSettings[plotIndex].lineThickness[dataIndex] = thickness;
            
            if (state.charts[plotIndex] && state.charts[plotIndex].data.datasets[dataIndex]) {
                state.charts[plotIndex].data.datasets[dataIndex].borderWidth = thickness;
                state.charts[plotIndex].update('none');
            }
        }

        // Toggle visibility of a data series
        function toggleDataVisibility(plotIndex, dataIndex, visible) {
            console.log(`Toggling visibility for plot ${plotIndex}, data ${dataIndex} to ${visible}`);
            state.plotSettings[plotIndex].visible[dataIndex] = visible;
            
            if (state.charts[plotIndex] && state.charts[plotIndex].data.datasets[dataIndex]) {
                state.charts[plotIndex].data.datasets[dataIndex].hidden = !visible;
                state.charts[plotIndex].update('none');
            }
        }

        // Update axis label
        function updateAxisLabel(plotIndex, axis, label) {
            console.log(`Updating ${axis}-axis label for plot ${plotIndex} to "${label}"`);
            state.plotSettings[plotIndex][`${axis}Label`] = label;
            
            if (state.charts[plotIndex]) {
                state.charts[plotIndex].options.scales[axis].title.text = label;
                state.charts[plotIndex].update('none');
            }
        }

        // Update legend label
        function updateLegendLabel(plotIndex, dataIndex, label) {
            console.log(`Updating legend label for plot ${plotIndex}, data ${dataIndex} to "${label}"`);
            state.plotSettings[plotIndex].legendLabels[dataIndex] = label;
            updateLegends();
        }

        // Update MA window size
        function updateMaWindow(plotIndex, dataIndex, windowSize) {
            console.log(`Updating MA window for plot ${plotIndex}, data ${dataIndex} to ${windowSize}`);
            state.plotSettings[plotIndex].maWindow[dataIndex] = windowSize;
            
            // Recalculate moving averages
            if (state.charts[plotIndex] && state.charts[plotIndex].data.datasets[dataIndex]) {
                calculateMovingAverage(plotIndex, dataIndex);
                state.charts[plotIndex].update('none');
            }
        }

        // Toggle MA visibility
        function toggleMaVisibility(plotIndex, dataIndex, visible) {
            console.log(`Toggling MA visibility for plot ${plotIndex}, data ${dataIndex} to ${visible}`);
            state.plotSettings[plotIndex].maVisible[dataIndex] = visible;
            
            // Find the MA dataset (it's at index dataIndex + dataCount)
            const dataCount = state.charts[plotIndex].data.datasets.length / 2;
            const maDatasetIndex = dataIndex + dataCount;
            
            if (state.charts[plotIndex] && state.charts[plotIndex].data.datasets[maDatasetIndex]) {
                state.charts[plotIndex].data.datasets[maDatasetIndex].hidden = !visible;
                state.charts[plotIndex].update('none');
            }
            
            updateLegends();
        }

        // Update MA legend label
        function updateMaLegendLabel(plotIndex, dataIndex, label) {
            console.log(`Updating MA legend label for plot ${plotIndex}, data ${dataIndex} to "${label}"`);
            state.plotSettings[plotIndex].maLegendLabels[dataIndex] = label;
            updateLegends();
        }

        // Calculate moving average for a data series
        function calculateMovingAverage(plotIndex, dataIndex) {
            const chart = state.charts[plotIndex];
            const dataCount = chart.data.datasets.length / 2;
            const maDatasetIndex = dataIndex + dataCount;
            const windowSize = state.plotSettings[plotIndex].maWindow[dataIndex];
            
            if (!chart.data.datasets[maDatasetIndex]) return;
            
            // Clear existing MA data
            chart.data.datasets[maDatasetIndex].data = [];
            
            // Calculate moving average
            const originalData = chart.data.datasets[dataIndex].data;
            for (let i = 0; i < originalData.length; i++) {
                if (i < windowSize - 1) {
                    // Not enough data points for full window, calculate partial average
                    const windowData = originalData.slice(0, i + 1);
                    const sum = windowData.reduce((acc, point) => acc + point.y, 0);
                    const avg = sum / windowData.length;
                    
                    chart.data.datasets[maDatasetIndex].data.push({
                        x: originalData[i].x,
                        y: avg
                    });
                } else {
                    // Calculate full window average
                    const windowData = originalData.slice(i - windowSize + 1, i + 1);
                    const sum = windowData.reduce((acc, point) => acc + point.y, 0);
                    const avg = sum / windowSize;
                    
                    chart.data.datasets[maDatasetIndex].data.push({
                        x: originalData[i].x,
                        y: avg
                    });
                }
            }
        }

        // Export CSV for a plot

        function exportCSV(plotIndex) {
            console.log(`Exporting CSV for plot ${plotIndex}`);
            const chart = state.charts[plotIndex];
            const settings = state.plotSettings[plotIndex];
            
            if (!chart || chart.data.datasets.length === 0) {
                alert("No data to export!");
                return;
            }
            
            // Prepare CSV content
            let csvContent = "";
            
            // Get global CSV format settings
            const thousandSep = state.csvThousandSeparator === 'none' ? '' : state.csvThousandSeparator;
            const decimalSep = state.csvDecimalSeparator;
            const valueSep = state.csvValueSeparator;
            
            // Add headers
            const headers = ["X (" + settings.xLabel + ")"];
            const dataCount = chart.data.datasets.length / 2;
            
            for (let i = 0; i < dataCount; i++) {
                headers.push(settings.legendLabels[i] || `Data ${i}`);
                
                if (settings.maVisible[i]) {
                    headers.push(settings.maLegendLabels[i] || `MA ${i}`);
                }
            }
            
            csvContent += headers.join(valueSep) + "\n";
            
            // Add data rows
            const maxDataPoints = Math.max(...chart.data.datasets.map(ds => ds.data.length));
            
            for (let i = 0; i < maxDataPoints; i++) {
                const row = [];
                
                // Add X value (use the first dataset as reference)
                if (chart.data.datasets[0].data[i]) {
                    row.push(chart.data.datasets[0].data[i].x);
                } else {
                    row.push("");
                }
                
                // Add Y values for each dataset
                for (let j = 0; j < dataCount; j++) {
                    if (chart.data.datasets[j].data[i]) {
                        // Format number with thousand and decimal separators
                        let value = chart.data.datasets[j].data[i].y.toString();
                        
                        // Apply thousand separator if needed
                        if (thousandSep && value.includes('.')) {
                            const parts = value.split('.');
                            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, thousandSep);
                            value = parts.join(decimalSep);
                        } else if (thousandSep) {
                            value = value.replace(/\B(?=(\d{3})+(?!\d))/g, thousandSep);
                        }
                        
                        // Replace decimal point if needed
                        if (decimalSep !== '.') {
                            value = value.replace('.', decimalSep);
                        }
                        
                        row.push(value);
                    } else {
                        row.push("");
                    }
                    
                    // Add MA values if visible
                    if (settings.maVisible[j]) {
                        const maIndex = j + dataCount;
                        if (chart.data.datasets[maIndex].data[i]) {
                            // Format number with thousand and decimal separators
                            let maValue = chart.data.datasets[maIndex].data[i].y.toString();
                            
                            // Apply thousand separator if needed
                            if (thousandSep && maValue.includes('.')) {
                                const parts = maValue.split('.');
                                parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, thousandSep);
                                maValue = parts.join(decimalSep);
                            } else if (thousandSep) {
                                maValue = maValue.replace(/\B(?=(\d{3})+(?!\d))/g, thousandSep);
                            }
                            
                            // Replace decimal point if needed
                            if (decimalSep !== '.') {
                                maValue = maValue.replace('.', decimalSep);
                            }
                            
                            row.push(maValue);
                        } else {
                            row.push("");
                        }
                    }
                }
                
                csvContent += row.join(valueSep) + "\n";
            }
            
            // Create download link
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            const date = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            
            link.setAttribute("href", url);
            link.setAttribute("download", `plot_${plotIndex + 1}_data_${date}.csv`);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log("CSV exported successfully");
        }

        // Toggle serial connection
        async function toggleConnection() {
            console.log("Toggle connection clicked. Current state:", state.connected);
            if (state.connected) {
                disconnect();
            } else {
                await connect();
            }
        }

        // Connect to serial port
        async function connect() {
            console.log("Connecting to serial port...");
            try {
                if ('serial' in navigator) {
                    state.port = await navigator.serial.requestPort();
                    const baudRate = parseInt(document.getElementById('baud-rate').value);
                    console.log("Selected baud rate:", baudRate);
                    
                    await state.port.open({ baudRate });
                    
                    state.connected = true;
                    state.reader = state.port.readable.getReader();
                    state.dataBuffer = ""; // Clear buffer on connection
                    
                    console.log("Serial port opened successfully");
                    
                    // Start reading data
                    readData();
                    
                    updateUiState();
                } else {
                    console.error("WebSerial API not supported");
                    alert('WebSerial API not supported in this browser. Try Chrome or Edge.');
                }
            } catch (error) {
                console.error('Error connecting to serial port:', error);
                alert('Failed to connect: ' + error.message);
            }
        }

        // Disconnect from serial port
        async function disconnect() {
            console.log("Disconnecting from serial port...");
            if (state.reader) {
                await state.reader.cancel();
                state.reader = null;
            }
            
            if (state.port) {
                await state.port.close();
                state.port = null;
            }
            
            state.connected = false;
            state.dataBuffer = ""; // Clear buffer on disconnect
            updateUiState();
            console.log("Disconnected from serial port");
        }

        // Read data from serial port
        async function readData() {
            console.log("Starting to read data from serial port");
            while (state.connected && state.port) {
                try {
                    const { value, done } = await state.reader.read();
                    
                    if (done) {
                        console.log("Reader done, breaking read loop");
                        break;
                    }
                    
                    if (value) {
                        // Convert to text and add to buffer
                        const text = new TextDecoder().decode(value);
                        state.dataBuffer += text;
                        console.log("Data added to buffer. Buffer content:", state.dataBuffer);
                        
                        // Process complete lines from buffer
                        processBuffer();
                    }
                } catch (error) {
                    console.error('Error reading data:', error);
                    disconnect();
                    break;
                }
            }
        }

        // Process the data buffer to extract complete lines
        function processBuffer() {
            // Check if we have at least one complete line (ending with newline)
            const newlineIndex = state.dataBuffer.indexOf('\n');
            
            if (newlineIndex !== -1) {
                // Extract the complete line
                const completeLine = state.dataBuffer.substring(0, newlineIndex);
                
                // Remove the processed data from buffer
                state.dataBuffer = state.dataBuffer.substring(newlineIndex + 1);
                
                console.log("Processing complete line:", completeLine);
                processData(completeLine);
                
                // Check if there are more complete lines in the buffer
                if (state.dataBuffer.includes('\n')) {
                    processBuffer();
                }
            }
        }

        // Process incoming data
        function processData(line) {
            console.log("Processing line:", line);
            
            if (line.trim() === '') {
                console.log("Skipping empty line");
                return;
            }
            
            // Split by commas and convert to numbers
            const values = line.split(',').map(val => parseFloat(val.trim()));
            console.log("Parsed values:", values);
            
            // Filter out NaN values
            const validValues = values.filter(val => !isNaN(val));
            console.log("Valid values:", validValues);
            
            if (validValues.length > 0) {
                addDataPoint(validValues);
            } else {
                console.log("No valid values in line");
            }
        }

        // Add a data point to the charts
        function addDataPoint(values) {
            if (!state.plotting) {
                console.log("Plotting paused, skipping data point");
                return;
            }
            
            state.dataPoints++;
            document.getElementById('data-count').textContent = state.dataPoints;
            console.log(`Data point ${state.dataPoints}:`, values);
            
            // Add data to each chart
            for (let i = 0; i < state.plotCount; i++) {
                const startIndex = state.separatorIndices[i];
                const endIndex = i < state.plotCount - 1 ? state.separatorIndices[i + 1] : undefined;
                const plotValues = values.slice(startIndex, endIndex);
                
                console.log(`Plot ${i} (indices ${startIndex}-${endIndex || 'end'}):`, plotValues);
                
                // Ensure we have datasets for each value
                if (state.charts[i].data.datasets.length !== plotValues.length * 2) {
                    console.log(`Initializing ${plotValues.length * 2} datasets for plot ${i}`);
                    initializeDatasets(i, plotValues.length);
                }
                
                // Add data to each dataset
                for (let j = 0; j < plotValues.length; j++) {
                    if (state.charts[i].data.datasets[j]) {
                        state.charts[i].data.datasets[j].data.push({
                            x: state.dataPoints,
                            y: plotValues[j]
                        });
                        
                        // Calculate moving average if enabled
                        if (state.plotSettings[i].maVisible[j]) {
                            calculateMovingAverage(i, j);
                        }
                    }
                }
                
                // Update X-axis to implement roll-over
                updateXAxis(i);
                
                state.charts[i].update('none');
            }
            
            console.log("Data added to all plots");
        }

        // Update X-axis to implement roll-over effect
        function updateXAxis(plotIndex) {
            const chart = state.charts[plotIndex];
            const scaleState = chart.scaleState;
            
            // Calculate the current X range
            const currentRange = scaleState.xMax - scaleState.xMin;
            
            // If we've reached the end of the current range, shift the window
            if (state.dataPoints > scaleState.xMax) {
                scaleState.xMin = state.dataPoints - currentRange;
                scaleState.xMax = state.dataPoints;
                
                // Update chart options
                chart.options.scales.x.min = scaleState.xMin;
                chart.options.scales.x.max = scaleState.xMax;
                
                console.log(`Plot ${plotIndex} X-axis shifted to [${scaleState.xMin}, ${scaleState.xMax}]`);
            }
        }

        // Initialize datasets for a chart
        function initializeDatasets(plotIndex, count) {
            console.log(`Initializing ${count * 2} datasets for plot ${plotIndex}`);
            const startIndex = state.separatorIndices[plotIndex];
            const settings = state.plotSettings[plotIndex];
            
            state.charts[plotIndex].data.datasets = [];
            
            // Create datasets for original data
            for (let i = 0; i < count; i++) {
                const dataIndex = startIndex + i;
                
                state.charts[plotIndex].data.datasets.push({
                    label: settings.legendLabels[i] || `Data ${dataIndex}`,
                    borderColor: lineColors[dataIndex % lineColors.length],
                    backgroundColor: 'rgba(0, 0, 0, 0)',
                    data: [],
                    borderWidth: settings.lineThickness[i] || 2,
                    pointRadius: 0,
                    fill: false,
                    hidden: !settings.visible[i]
                });
            }
            
            // Create datasets for moving averages
            for (let i = 0; i < count; i++) {
                const dataIndex = startIndex + i;
                
                state.charts[plotIndex].data.datasets.push({
                    label: settings.maLegendLabels[i] || `MA ${dataIndex}`,
                    borderColor: maLineColors[dataIndex % maLineColors.length],
                    backgroundColor: 'rgba(0, 0, 0, 0)',
                    data: [],
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: false,
                    hidden: !settings.maVisible[i],
                    /*borderDash: [5, 5]*/  // this line makse the dashes for the moving average
                });
            }
            
            state.charts[plotIndex].update();
            console.log(`Datasets initialized for plot ${plotIndex}`);
        }

        // Toggle plotting
        function togglePlotting() {
            console.log("Toggle plotting. Current state:", state.plotting);
            state.plotting = !state.plotting;
            console.log("New plotting state:", state.plotting);
            updateUiState();
        }

        // Clear a specific plot
        function clearPlot(plotIndex) {
            console.log(`Clearing plot ${plotIndex}`);
            if (state.charts[plotIndex]) {
                state.charts[plotIndex].data.datasets.forEach(dataset => {
                    dataset.data = [];
                });
                // Reset scale state
                const chart = state.charts[plotIndex];
                chart.scaleState = {
                    yMin: null,
                    yMax: null,
                    xRange: 100,
                    xMin: 0,
                    xMax: 100
                };
                chart.options.scales.x.min = 0;
                chart.options.scales.x.max = 100;
                chart.update();
                console.log(`Plot ${plotIndex} cleared`);
            }
        }

        // Clear all plots
        function clearAllPlots() {
            console.log("Clearing all plots");
            state.dataPoints = 0;
            document.getElementById('data-count').textContent = '0';
            
            for (let i = 0; i < state.charts.length; i++) {
                clearPlot(i);
            }
            console.log("All plots cleared");
        }

        // Handle scale actions for plots
        function handleScaleAction(plotIndex, action) {
            console.log(`Handling scale action: ${action} on plot ${plotIndex}`);
            
            // For X-axis actions, apply to ALL charts to keep them synchronized
            if (action === 'increase-x' || action === 'decrease-x') {
                console.log("Synchronizing X-axis across all plots");
                
                for (let i = 0; i < state.charts.length; i++) {
                    if (!state.charts[i]) continue;
                    
                    const chart = state.charts[i];
                    const scaleState = chart.scaleState;
                    
                    switch (action) {
                        case 'increase-x':
                            console.log("Increasing X range for all plots");
                            scaleState.xRange += 50;
                            scaleState.xMax = scaleState.xMin + scaleState.xRange;
                            chart.options.scales.x.max = scaleState.xMax;
                            break;
                            
                        case 'decrease-x':
                            console.log("Decreasing X range for all plots");
                            scaleState.xRange = Math.max(50, scaleState.xRange - 50);
                            scaleState.xMax = scaleState.xMin + scaleState.xRange;
                            chart.options.scales.x.max = scaleState.xMax;
                            break;
                    }
                    
                    chart.update('none');
                }
            } 
            else {
                // Y-axis actions only affect the specific plot
                if (!state.charts[plotIndex]) {
                    console.error(`Plot ${plotIndex} not found`);
                    return;
                }
                
                const chart = state.charts[plotIndex];
                const scaleState = chart.scaleState;
                
                switch (action) {
                    case 'autoscale':
                        console.log("Applying autoscale to Y axis");
                        scaleState.yMin = null;
                        scaleState.yMax = null;
                        chart.options.scales.y.min = null;
                        chart.options.scales.y.max = null;
                        break;
                        
                    case 'increase-y':
                        console.log("Increasing Y scale (zooming out)");
                        if (scaleState.yMin === null || scaleState.yMax === null) {
                            // If no manual scale is set, calculate from data
                            const yValues = chart.data.datasets.flatMap(d => d.data.map(point => point.y));
                            if (yValues.length > 0) {
                                const minY = Math.min(...yValues);
                                const maxY = Math.max(...yValues);
                                const range = maxY - minY;
                                
                                scaleState.yMin = minY - range * 0.1;
                                scaleState.yMax = maxY + range * 0.1;
                            } else {
                                scaleState.yMin = -10;
                                scaleState.yMax = 10;
                            }
                        } else {
                            // Expand the scale by 20%
                            const range = scaleState.yMax - scaleState.yMin;
                            scaleState.yMin -= range * 0.1;
                            scaleState.yMax += range * 0.1;
                        }
                        chart.options.scales.y.min = scaleState.yMin;
                        chart.options.scales.y.max = scaleState.yMax;
                        break;
                        
                    case 'decrease-y':
                        console.log("Decreasing Y scale (zooming in)");
                        if (scaleState.yMin === null || scaleState.yMax === null) {
                            // If no manual scale is set, calculate from data
                            const yValues = chart.data.datasets.flatMap(d => d.data.map(point => point.y));
                            if (yValues.length > 0) {
                                const minY = Math.min(...yValues);
                                const maxY = Math.max(...yValues);
                                const range = maxY - minY;
                                
                                scaleState.yMin = minY + range * 0.1;
                                scaleState.yMax = maxY - range * 0.1;
                            } else {
                                scaleState.yMin = -5;
                                scaleState.yMax = 5;
                            }
                        } else {
                            // Contract the scale by 20%
                            const range = scaleState.yMax - scaleState.yMin;
                            scaleState.yMin += range * 0.1;
                            scaleState.yMax -= range * 0.1;
                        }
                        chart.options.scales.y.min = scaleState.yMin;
                        chart.options.scales.y.max = scaleState.yMax;
                        break;

                }
                
                chart.update();
            }
            
            console.log(`Scale action ${action} completed`);
        }


        // Apply plot configuration
        function applyPlotConfig() {
            const indicesText = document.getElementById('data-format').value;
            console.log("Applying plot configuration. Input:", indicesText);
            
            const indices = indicesText.split(',').map(idx => parseInt(idx.trim()));
            console.log("Parsed indices:", indices);
            
            if (indices.length > 0 && indices.every(idx => !isNaN(idx))) {
                state.separatorIndices = indices;
                console.log("New separator indices:", state.separatorIndices);
                renderPlotWindows();
            } else {
                console.error("Invalid separator indices:", indices);
                alert('Please enter valid separator indices (e.g., "0,3,7")');
            }
        }

        // Update UI state based on current status
        function updateUiState() {
            console.log("Updating UI state. Connected:", state.connected, "Plotting:", state.plotting);
            
            const connectBtn = document.getElementById('connect-btn');
            const startStopBtn = document.getElementById('start-stop-btn');
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            
            // Update connection status
            if (state.connected) {
                connectBtn.innerHTML = '<span>Disconnect</span>';
                connectBtn.className = 'btn-danger';
                statusIndicator.className = 'status-indicator connected';
                statusText.textContent = 'Connected';
            } else {
                connectBtn.innerHTML = '<span>Connect</span>';
                connectBtn.className = 'btn-primary';
                statusIndicator.className = 'status-indicator disconnected';
                statusText.textContent = 'Disconnected';
            }
            
            // Update plotting status
            if (state.plotting) {
                startStopBtn.innerHTML = '<span>Stop Plotting</span>';
                startStopBtn.className = 'btn-danger';
            } else {
                startStopBtn.innerHTML = '<span>Start Plotting</span>';
                startStopBtn.className = 'btn-success';
            }
            
            console.log("UI state updated");
        }

        // Initialize the app when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>